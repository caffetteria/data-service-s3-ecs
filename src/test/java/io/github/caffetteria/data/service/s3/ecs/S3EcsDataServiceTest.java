package io.github.caffetteria.data.service.s3.ecs;

import lombok.extern.slf4j.Slf4j;
import org.fugerit.java.core.cfg.ConfigException;
import org.fugerit.java.simple.config.ConfigParams;
import org.fugerit.java.simple.config.ConfigParamsDefault;
import org.junit.jupiter.api.*;
import org.testcontainers.containers.localstack.LocalStackContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.*;
import static org.testcontainers.containers.localstack.LocalStackContainer.Service.S3;

@Slf4j
@Testcontainers
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class S3EcsDataServiceTest {

    private static final String TEST_BUCKET = "test-bucket";
    private static final String TEST_CONTENT = "Hello S3 Test Content!";
    private static final String TEST_RESOURCE_NAME = "test-resource.txt";

    @Container
    static LocalStackContainer localstack = new LocalStackContainer(
            DockerImageName.parse("localstack/localstack:3.0"))
            .withServices(S3);

    private S3EcsDataService dataService;
    private String savedETag;

    @BeforeEach
    void setUp() throws ConfigException {
        // Prepara la configurazione per il DataService
        Properties properties = new Properties();
        properties.setProperty(S3EcsDataService.BUCKET_NAME, TEST_BUCKET);
        properties.setProperty(S3EcsDataService.ENDPOINT, localstack.getEndpointOverride(S3).toString());
        properties.setProperty(S3EcsDataService.ACCESS_KEY, localstack.getAccessKey());
        properties.setProperty(S3EcsDataService.SECRET_KEY, localstack.getSecretKey());
        properties.setProperty(S3EcsDataService.CREATE_IF_NOT_EXISTS, "true");
        log.info( "Setting up S3EcsDataService with properties {}", properties );
        ConfigParams configParams = new ConfigParamsDefault(properties);
        // Inizializza il DataService
        dataService = S3EcsDataService.newDataService(configParams);
    }

    @Test
    @Order(1)
    @DisplayName("Test setup del DataService")
    void testSetup() {
        assertNotNull(dataService, "DataService should be initialized");
    }

    @Test
    @Order(2)
    @DisplayName("Test save con resource name specificato")
    void testSaveWithResourceName() throws IOException {
        // Given
        InputStream inputStream = new ByteArrayInputStream(TEST_CONTENT.getBytes(StandardCharsets.UTF_8));

        // When
        String etag = dataService.save(inputStream, TEST_RESOURCE_NAME);

        // Then
        assertNotNull(etag, "ETag should not be null");
        assertFalse(etag.isEmpty(), "ETag should not be empty");

        // Salva l'ETag per i test successivi
        savedETag = etag;

        log.info("Saved with ETag: {}", etag);
    }

    @Test
    @Order(3)
    @DisplayName("Test save con UUID generato automaticamente")
    void testSaveWithAutoGeneratedUUID() throws IOException {
        // Given
        String content = "Test content with auto-generated ID";
        InputStream inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));

        // When
        String etag = dataService.save(inputStream);

        // Then
        assertNotNull(etag, "ETag should not be null");
        assertFalse(etag.isEmpty(), "ETag should not be empty");

        log.info("Saved with auto-generated UUID, ETag: {}", etag);
    }

    @Test
    @Order(4)
    @DisplayName("Test load di una risorsa esistente")
    void testLoad() throws IOException {
        // Given - prima salva una risorsa
        String resourceName = "load-test-resource.txt";
        String expectedContent = "Content to be loaded";
        InputStream saveStream = new ByteArrayInputStream(expectedContent.getBytes(StandardCharsets.UTF_8));
        dataService.save(saveStream, resourceName);

        // When - carica la risorsa
        InputStream loadedStream = dataService.load(resourceName);

        // Then
        assertNotNull(loadedStream, "Loaded stream should not be null");

        String loadedContent = new String(readAllBytes(loadedStream), StandardCharsets.UTF_8);
        assertEquals(expectedContent, loadedContent, "Loaded content should match saved content");

        loadedStream.close();
    }

    @Test
    @Order(5)
    @DisplayName("Test load di risorsa salvata in precedenza")
    void testLoadPreviouslySavedResource() throws IOException {
        // When
        InputStream loadedStream = dataService.load(TEST_RESOURCE_NAME);

        // Then
        assertNotNull(loadedStream, "Loaded stream should not be null");

        String loadedContent = new String(readAllBytes(loadedStream), StandardCharsets.UTF_8);
        assertEquals(TEST_CONTENT, loadedContent, "Content should match");

        loadedStream.close();
    }

    @Test
    @Order(6)
    @DisplayName("Test save e load con contenuto binario")
    void testSaveAndLoadBinaryContent() throws IOException {
        // Given - dati binari
        byte[] binaryData = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, (byte) 0xFF, (byte) 0xFE};
        String resourceName = "binary-test.bin";
        InputStream inputStream = new ByteArrayInputStream(binaryData);

        // When - salva
        String etag = dataService.save(inputStream, resourceName);
        assertNotNull(etag);

        // Then - carica e verifica
        InputStream loadedStream = dataService.load(resourceName);
        byte[] loadedData = readAllBytes(loadedStream);

        assertArrayEquals(binaryData, loadedData, "Binary data should match");

        loadedStream.close();
    }

    @Test
    @Order(7)
    @DisplayName("Test save sovrascrive risorsa esistente")
    void testSaveOverwritesExistingResource() throws IOException {
        // Given
        String resourceName = "overwrite-test.txt";
        String content1 = "Original content";
        String content2 = "Updated content";

        // When - prima scrittura
        InputStream stream1 = new ByteArrayInputStream(content1.getBytes(StandardCharsets.UTF_8));
        String etag1 = dataService.save(stream1, resourceName);

        // seconda scrittura (sovrascrittura)
        InputStream stream2 = new ByteArrayInputStream(content2.getBytes(StandardCharsets.UTF_8));
        String etag2 = dataService.save(stream2, resourceName);

        // Then - gli ETag devono essere diversi
        assertNotEquals(etag1, etag2, "ETags should be different after overwrite");

        // Verifica che il contenuto sia quello aggiornato
        InputStream loadedStream = dataService.load(resourceName);
        String loadedContent = new String(readAllBytes(loadedStream), StandardCharsets.UTF_8);
        assertEquals(content2, loadedContent, "Content should be updated");

        loadedStream.close();
    }

    @Test
    @Order(8)
    @DisplayName("Test load di risorsa non esistente genera eccezione")
    void testLoadNonExistentResource() {
        // When & Then
        assertThrows(Exception.class, new org.junit.jupiter.api.function.Executable() {
            @Override
            public void execute() throws Throwable {
                dataService.load("non-existent-resource.txt");
            }
        }, "Loading non-existent resource should throw exception");
    }

    @Test
    @Order(9)
    @DisplayName("Test save con contenuto vuoto")
    void testSaveEmptyContent() throws IOException {
        // Given
        String resourceName = "empty-test.txt";
        InputStream emptyStream = new ByteArrayInputStream(new byte[0]);

        // When
        String etag = dataService.save(emptyStream, resourceName);

        // Then
        assertNotNull(etag, "ETag should not be null even for empty content");

        // Verifica che il file vuoto sia stato salvato
        InputStream loadedStream = dataService.load(resourceName);
        byte[] loadedData = readAllBytes(loadedStream);
        assertEquals(0, loadedData.length, "Loaded content should be empty");

        loadedStream.close();
    }

    @Test
    @Order(10)
    @DisplayName("Test configurazione duplicata genera eccezione")
    void testDuplicateSetupThrowsException() {
        // Given
        Properties properties = new Properties();
        properties.setProperty(S3EcsDataService.BUCKET_NAME, "another-bucket");
        properties.setProperty(S3EcsDataService.ENDPOINT, localstack.getEndpointOverride(S3).toString());
        properties.setProperty(S3EcsDataService.ACCESS_KEY, localstack.getAccessKey());
        properties.setProperty(S3EcsDataService.SECRET_KEY, localstack.getSecretKey());

        ConfigParams configParams = new ConfigParamsDefault(properties);

        // When & Then
        assertThrows(ConfigException.class, new org.junit.jupiter.api.function.Executable() {
            @Override
            public void execute() throws Throwable {
                dataService.setup(configParams);
            }
        }, "Setup should throw ConfigException when called twice");
    }

    @Test
    @Order(11)
    @DisplayName("Test save con contenuto di grandi dimensioni")
    void testSaveLargeContent() throws IOException {
        // Given - crea un contenuto di ~1MB
        StringBuilder largeContent = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            largeContent.append("This is line ").append(i).append(" of a large file.\n");
        }

        String resourceName = "large-file.txt";
        byte[] data = largeContent.toString().getBytes(StandardCharsets.UTF_8);
        InputStream inputStream = new ByteArrayInputStream(data);

        // When
        String etag = dataService.save(inputStream, resourceName);

        // Then
        assertNotNull(etag);

        // Verifica il caricamento
        InputStream loadedStream = dataService.load(resourceName);
        byte[] loadedData = readAllBytes(loadedStream);
        assertEquals(data.length, loadedData.length, "File size should match");

        loadedStream.close();

        log.info("Large file size: {} bytes", data.length);
    }

    @Test
    @Order(12)
    @DisplayName("Test save con caratteri speciali nel nome risorsa")
    void testSaveWithSpecialCharactersInResourceName() throws IOException {
        // Given
        String resourceName = "folder/subfolder/file-with-special-chars_123.txt";
        String content = "File in folder structure";
        InputStream inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));

        // When
        String etag = dataService.save(inputStream, resourceName);

        // Then
        assertNotNull(etag);

        // Verifica il caricamento
        InputStream loadedStream = dataService.load(resourceName);
        String loadedContent = new String(readAllBytes(loadedStream), StandardCharsets.UTF_8);
        assertEquals(content, loadedContent);

        loadedStream.close();
    }

    /**
     * Metodo helper per leggere tutti i byte da un InputStream (Java 8 compatible)
     */
    private byte[] readAllBytes(InputStream inputStream) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        int nRead;
        byte[] data = new byte[4096];

        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, nRead);
        }

        buffer.flush();
        return buffer.toByteArray();
    }

    @AfterEach
    void tearDown() {
        // Cleanup se necessario
    }
}